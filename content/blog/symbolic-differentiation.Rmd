---
author: "Rich FitzJohn"
title: "Symbolic differentiation in a few lines of code"
date: 2023-06-16
tags:
- R
---

<!--
Render original source Rmd with:

Rscript -e 'rmarkdown::render("symbolic-differentiation.Rmd", output_format=rmarkdown::md_document(preserve_yaml = TRUE, variant = "markdown_github"))'

-->

We are working on [automatic differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation) of [odin](https://mrc-ide.github.io/odin/) models, and to support this we need support for differentiating expressions symbolically, in order to write new equations that can be used to numerically propagate derivatives of a model.

R already has support for doing this via the `D` function:

```{r}
D(quote(2 * x^2 * log(sqrt(x))), "x")
```

and the [`Deriv`](https://cran.r-project.org/package=Deriv) provides an extensible interface. However, `odin` has peculiar syntax with arrays and we're interested in doing trying to differentiate through stochastic functions, so a bespoke solution felt useful.

Symbolic differentiation turns out to be surprisingly easy, and quite elegant, to implement; this post shows the general idea.

To start, consider differentiating the expression `x^2 + x^3` with respect to `x`.  Recall the mechanical rules of differentiation from school that we can write this as `d/dx x^2 + d/dx x^3` and then that we differentiate functions of the form `x^n` as `n x^(n - 1)` -- this is the primary insight we need; that the process is recursive as we break down every operation into smaller chunks and keep on differentiating interior expressions with respect to `x` until there's nothing left.

The simplest possible differentiation rules concern numbers; `d/dx n` for any number `n` is zero (that is, the gradient of `n` with respect to `x` is zero. Similarly, for any symbol (say `a` but not `a + b`) *except* `x` the derivative is also zero. And the derivative of `x` with respect to `x` is one. With this, we have the edge case for a recursive function:

```{r}
differentiate <- function(expr, name) {
  if (!is.recursive(expr)) {
    if (identical(expr, as.symbol(name))) 1 else 0
  } else {
    stop("not yet implemented")
  }
}
```

which we can apply like so:

```{r}
differentiate(quote(x), "x")
differentiate(quote(a), "x")
differentiate(quote(1), "x")
```

Interesting expressions are not supported yet:

```{r, error = TRUE}
differentiate(quote(x + x * x), "x")
```

To implement the case where we have compound expressions (`is.recursive(expr)` returning `TRUE`), consider the way we can represent these expressions:

```{r}
expr <- quote(x + x * x)
as.list(expr)
```

Every call can be represented this way - the first element is the function being called and the remaining elements are its arguments. This structure is recursive:

```{r}
as.list(expr[[3]])
```

To apply our differentiation rules we need to describe how to handle each function (here, `+` and `*`) and put together the results, descending into the subexpressions with `differentiate()` again until we git our edge cases.

The rule for differentiating sums is very straightforward, as noted above; we take the sum of the derivatives!

```{r}
d_plus <- function(expr, name) {
  call("+", differentiate(expr[[2]], name), differentiate(expr[[3]], name))
}
```

The `call()` function constructs expression arguments (so `call("+", quote(x), 1)` returns `x + 1`) and here we are descending into each expression with `differentiate()`.  We then rewrite `differentiate()` to call `d_plus()` when required:

```{r}
differentiate <- function(expr, name) {
  if (!is.recursive(expr)) {
    if (identical(expr, as.symbol(name))) 1 else 0
  } else {
    fn <- as.character(expr[[1]])
    switch(fn,
           "+" = d_plus(expr, name),
           stop("not yet implemented"))
  }
}
```


With this we can differentiate a sum of any depth:

```{r}
differentiate(quote(x + 5), "x")
differentiate(quote(x + y + x), "x")
```

We can then proceed, writing out rules for different functions as we need them. For example, the product rule:

```{r}
d_product <- function(expr, name) {
  a <- expr[[2]]
  b <- expr[[3]]
  da <- differentiate(a, name)
  db <- differentiate(b, name)
  call("+", call("*", da, b), call("*", a, db))
}
```

or the quotient rule

```{r}
d_quotient <- function(expr, name) {
  a <- expr[[2]]
  b <- expr[[3]]
  da <- differentiate(a, name)
  db <- differentiate(b, name)
  ## da / b + a * db / (b * b)
  call("-", call("/", da, b), call("/", call("*", a, db), call("*", b, b)))
}
```

For subtraction, we need to distinguish between unary minus (e.g., `-a`) and subtraction (e.g., `a - b`)

```{r}
d_minus <- function(expr, name) {
  if (length(expr) == 2) {
    call("-", differentiate(expr[[2]], name))
  } else {
    call("-", differentiate(expr[[2]], name), differentiate(expr[[3]], name))
  }
}
```

It turns out that `(` is a function too, and also needs a rule, but it is very simple:

```{r}
d_parenthesis <- function(expr, name) {
  call("(", differentiate(expr[[2]], name))
}
```

We can put all these rules into a list:

```{r}
rules <- list(
  "+" = d_plus,
  "-" = d_minus,
  "*" = d_product,
  "/" = d_quotient,
  "(" = d_parenthesis)
```

and rewrite our `differentiate()` implementation again:

```{r}
differentiate <- function(expr, name) {
  if (!is.recursive(expr)) {
    if (identical(expr, as.symbol(name))) 1 else 0
  } else {
    fn <- as.character(expr[[1]])
    if (!(fn %in% names(rules))) {
      stop(sprintf("Differentiation of '%s' not yet implemented", fn))
    }
    rules[[fn]](expr, name)
  }
}
```

and with this we can differentiate all sorts of things:

```{r}
differentiate(quote(-2 * x / (x * x - 3 * x)), "x")
```

This is fine, except that the generated expressions are fairly ugly, with lots of obviously redundant expressions (e.g., `-0 * x` which is obviously `0` and `+ -2 * 1` which is just `- 2`). However, the expressions agree with those from `D` once evaluated:

```
eval(differentiate(quote(-2 * x / (x * x - 3 * x)), "x"), list(x = pi))
eval(D(quote(-2 * x / (x * x - 3 * x)), "x"), list(x = pi))
```

## Extending the implementation by adding more rules

We could extend this easily now by adding more rules, and the implementation will even tell us what we need to add. So if we try and evaluate

```{r, error = TRUE}
differentiate(quote(exp(2 * x)), "x")
```

we get told to we need to implement the rule for `exp` which is simply:

```{r}
d_exp <- function(expr, name) {
  call("*", differentiate(expr[[2]], name), expr)
}
```

(that is, `d/dx exp(f(x))` is `f'(x) exp(f(x)))`. We add this to our set of rules:

```{r}
rules$exp <- d_exp
```

and now we can differentiate this new expression:

```{r}
differentiate(quote(exp(2 * x)), "x")
```

## Improving the implementation by writing sensible expressions

Simplifying the expressions turns out to be much more work than the differentiation. The trick that we use is to avoid using `call()` directly to build expressions and create a simplifying expression builder that applies some simple rules to avoid building overly complicated expressions.  This does not simplify everything, but cuts out the most egregious bits of noise.

This is probably not important for the efficiency of generated code (we're going to send this to an optimising compiler via some C++ code eventually) but it does make the resulting expressions easier to think about.

Consider replacing `call("+", a, b)` with something that will avoid creating silly expressions.  If given numeric arguments for `a` and `b` we should sum them, and if either of `a` or `b` is zero we should return the other argument:

```{r}
m_plus <- function(a, b) {
  if (is.numeric(a) && is.numeric(b)) {
    a + b
  } else if (is.numeric(b)) {
    m_plus(b, a)
  } else if (is.numeric(a) && a == 0) {
    b
  } else {
    call("+", a, b)
  }
}
```

The pattern here is that only the last branch gives up and actually builds an expression with `call()`

```{r}
m_plus(3, 4)
m_plus(quote(a), 0)
m_plus(quote(a), 1)
m_plus(0, quote(b))
m_plus(1, quote(b))
m_plus(quote(a), quote(b))
```

We can do similar things with multiplication:

```{r}
m_product <- function(a, b) {
  if (is.numeric(a) && is.numeric(b)) {
    a * b
  } else if (is.numeric(b)) {
    m_product(b, a)
  } else if (is.numeric(a) && a == 0) {
    0
  } else if (is.numeric(a) && a == 1) {
    b
  } else {
    call("*", a, b)
  }
}
m_product(3, 4)
m_product(quote(a), 0)
m_product(quote(a), 1)
m_product(quote(a), 2)
m_product(quote(a), quote(b))
```

unary minus

```{r}
is_call <- function(x, name) {
  is.recursive(x) && as.character(x[[1]]) == name
}
m_uminus <- function(a) {
  if (is.numeric(a)) {
    -a
  } else if (length(x) == 2 && identical(x[[1]], quote(`-`))) {
    a[[2]]
  } else if (is_call(a, "(")) {
    m_minus(a[[2]])
  } else {
    call("-", a)
  }
}
```

subtraction

```{r}
m_minus <- function(a, b) {
  if (is.numeric(a) && is.numeric(b)) {
    a - b
  } else if (is.numeric(a) && a == 0) {
    m_uminus(b)
  } else if (is.numeric(b) && b == 0) {
    a
  } else {
    call("-", a, b)
  }
}
```

and division

```{r}
m_quotient <- function(a, b) {
  if (is.numeric(a) && is.numeric(b)) {
    a / b
  } else if (is.numeric(a) && a == 0) {
    0
  } else if (is.numeric(b) && b == 0) {
    Inf
  } else if (is.numeric(b) && b == 1) {
    Inf
  } else {
    call("/", a, b)
  }
}
```

Finally, parentheses (this is done differently in our implementation but this is a little simpler):

```{r}
m_parenthesis <- function(a) {
  if (is.symbol(a) || is.numeric(a)) {
    a
  } else {
    call("(", a)
  }
}
```

We can then rewrite all our rules to use these functions instead of `call()` directly:

```{r}
d_plus <- function(expr, name) {
  m_plus(differentiate(expr[[2]], name), differentiate(expr[[3]], name))
}

d_minus <- function(expr, name) {
  if (length(expr) == 2) {
    m_uminus(differentiate(expr[[2]], name))
  } else {
    m_minus(differentiate(expr[[2]], name), differentiate(expr[[3]], name))
  }
}

d_product <- function(expr, name) {
  a <- expr[[2]]
  b <- expr[[3]]
  da <- differentiate(a, name)
  db <- differentiate(b, name)
  m_plus(m_product(da, b), m_product(a, db))
}

d_quotient <- function(expr, name) {
  a <- expr[[2]]
  b <- expr[[3]]
  da <- differentiate(a, name)
  db <- differentiate(b, name)
  ## da / b + a * db / (b * b)
  m_minus(m_quotient(da, b), m_quotient(m_product(a, db), m_product(b, b)))
}

d_parenthesis <- function(expr, name) {
  m_parenthesis(differentiate(expr[[2]], name))
}

rules <- list(
  "+" = d_plus,
  "-" = d_minus,
  "*" = d_product,
  "/" = d_quotient,
  "(" = d_parenthesis)
```

Now, when we call `differentiate()`, things look much nicer:

```{r}
differentiate(quote(-2 * x / (x * x - 3 * x)), "x")
```

There are still some weirdnesses here (e.g., `a - -2 * x * (x + x - 3)` which are surprisingly hard to undo; the rhs of this expression is a tree with structure:

```{r}
lobstr::ast(-2 * x * (x + x - 3))
```

so to simplify subtraction we have to extract the `-` from within two layers of multiplication, which is yet more recursion.

Our full implementation can be seen in [this pull request](https://github.com/mrc-ide/odin/pull/298/files), which follows the presentation here fairly closely.


